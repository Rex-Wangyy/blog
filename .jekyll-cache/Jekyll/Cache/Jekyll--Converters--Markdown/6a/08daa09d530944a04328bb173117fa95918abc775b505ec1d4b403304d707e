I"L<p>##</p>

<h2 id="kubernrtes">Kubernrtes</h2>

<p><strong>学习书籍</strong>：Kubernetes in Action  中文版</p>

<h3 id="容器与虚拟机">容器与虚拟机</h3>

<p>使用容器来隔离与虚拟机的区别，虚拟机会有额外的开销，导致不能给每个应用单开一个虚拟机。虚拟机中的应用会执行虚拟机的系统调用，然后虚拟机内核会通过管理程序在宿主机上执行x86指令。容器则会直接执行宿主机上同一个内核的系统调用。</p>

<h3 id="容器隔离">容器隔离</h3>

<p>容器隔离一般有两种方式：</p>

<ol>
  <li>Linux命名空间，每个进程只能看到自己的系统视图（文件，进程，网络接口，主机名等）</li>
  <li>Linux控制组(cgroups)，它限制了进程能适用的系统资源（CPU，内存，网络等）</li>
</ol>

<h4 id="命名空间">命名空间</h4>

<p>每种命名空间用来隔离一组特定的资源</p>

<ol>
  <li>Mount（mmt）</li>
  <li>Process ID（pid）</li>
  <li>Network（net） 能看见哪些网络接口</li>
  <li>Inter-process communicaion（ipd）</li>
  <li>UTS  能看见哪些主机和域名</li>
  <li>User ID（user）</li>
</ol>

<h3 id="k8s核心功能">k8s核心功能</h3>

<p>应用提交到主节点后，k8s会将它们部署到集群的工作节点，如指定一些应用必须一起运行，k8s会将它们部署在一个工作节点上，其余的将会被分散部署到集群。k8s集群由很多节点组成，节点分为两种类型：</p>

<ol>
  <li>主节点：承载k8s控制和管理整个集群的控制面板</li>
  <li>工作节点：运行用户实际部署的应用</li>
</ol>

<ul>
  <li>
    <p>控制面板</p>

    <p>用于控制集群使它工作，包含多个组件，可运行在单个主节点或通过副本分别部署在多个主节点以确保高可用性。这些组件持有并控制集群状态，但是不运行应用程序。</p>

    <ul>
      <li>k8s API 服务器，你和其他控制面板组件都需要和它通信</li>
      <li>Scheculer，调度应用，为应用的每个可部署组件分配工作节点</li>
      <li>Controller Manager，执行集群级别的功能，如复制组件，持续跟踪工作节点，处理节点失败</li>
      <li>etcd，可靠的分布式数据存储，持久化存储集群配置</li>
    </ul>
  </li>
  <li>
    <p>工作节点</p>

    <p>运行容器化的机器</p>

    <ul>
      <li>Docker，rtk 或其他容器</li>
      <li>Kubelet，与 API 服务器通信，管理所在的节点的容器</li>
      <li>Kubernetes Service Proxy（kube-proxy），组件间的负载均衡网络流量</li>
    </ul>
  </li>
</ul>

<h3 id="k8s部署应用">k8s部署应用</h3>

<p>一旦应用程序运行起来后，k8s 会不断的确认程序的部署状态始终与你提供的描述相匹配，如你需要5个web服务器实例，那么k8s总是保持正好运行5个实例，如果实例停止正常响应（崩溃），k8s会自动重启它。如果整个工作节点死亡，k8s将为在故障节点上运行的所有容器重新选择节点，并在新节点上运行它们。</p>

:ET